#include "particle.h"
#include "spring.h"
#include "particleSystem.h"

/* ----------------------------- ParticleSystem ----------------------------- */

// constructor initialises number of particles as passed
ParticleSystem::ParticleSystem(int nParticles)
  : m_numParticles(nParticles)
    {}

ParticleSystem::ParticleSystem()
{}

void ParticleSystem::connectParticles(Particle* p1, Particle* p2)
{
  // add 2-way connection (undirected)
  p1->m_neighbour_ids.push_back(p2->m_id);
  p2->m_neighbour_ids.push_back(p1->m_id);

  unsigned long int spring_id = Spring::generateSpringID(p1->m_id, p2->m_id);

  m_id_to_spring.emplace(std::piecewise_construct,
                         std::forward_as_tuple(spring_id),
                         std::forward_as_tuple(p1, p2) );

  p1->m_attached_spring_ids.push_back(spring_id);
  p2->m_attached_spring_ids.push_back(spring_id);
}

void ParticleSystem::connectParticles(Particle* p1, Particle* p2, float rest_len, float stiffness)
{
  // add 2-way connection (undirected)
  p1->m_neighbour_ids.push_back(p2->m_id);
  p2->m_neighbour_ids.push_back(p1->m_id);

  unsigned long int spring_id = Spring::generateSpringID(p1->m_id, p2->m_id);

  m_id_to_spring.emplace(std::piecewise_construct,
                         std::forward_as_tuple(spring_id),
                         std::forward_as_tuple(p1, p2, rest_len, stiffness) );

  p1->m_attached_spring_ids.push_back(spring_id);
  p2->m_attached_spring_ids.push_back(spring_id);
}

Vector3f ParticleSystem::computeGravity(float particle_mass)
{
  // compute gravity force
  // ... (assuming masses of all particles equal)
  // using the 9.8m/s^2 approximation:
  return 1.f * Vector3f(0.f, -9.8, 0.f) * particle_mass;
}

Vector3f ParticleSystem::computeViscousDrag(Particle& p, float particle_mass)
{
  Vector3f viscous_drag(0.f); // we will compute the net viscous drag

  // 2. compute viscous drag [F = -kx', where k=drag, x'=velocity]
  // ... (go through every spring the particle is connected to)
  //dbug dvar(p.m_attached_spring_ids.size()) eol;
  for (unsigned int i = 0; i < p.m_attached_spring_ids.size(); i++)
  { // compute the force generated by ALL springs attached to particle.
    // get the drag constant of an attached spring:
    // float k = m_id_to_spring.find(p.m_attached_spring_ids[i])->second.m_stiffness;
    float k = 0.3;

    // add to the net drag force;
    // ... viscous_drag = stiffness coef * velocity
    viscous_drag += -1.f * k * p.m_speed; //  odd state indices are particle velocity
  }

  return viscous_drag;
}


Vector3f ParticleSystem::computeSpringForce(Particle& p, float particle_mass)
{
  // 3. compute spring force:
  /*
  where k=drag, dist=xi-xj - distance between neighbouring particles
    F = -k * (abs(dist) - r) * dist/abs(dist),
          r=rest length of spring (member var 'm_rest_length')
  */
  // ... (go through every spring the particle is connected to)
  Vector3f spring_force(0.f);

  // for (int j = 0; j < nr_attached_springs; j++)
  for (unsigned int i = 0; i < p.m_attached_spring_ids.size(); i++)
  {
    Spring* spring = &m_id_to_spring.find(p.m_attached_spring_ids[i])->second;
    // particle position is stored at even numbers in the state ...
    // ... hence multiplied by 2:
    // Vector3f distance = spring->m_particle2->m_position - spring->m_particle1->m_position;
    Vector3f distance;
    unsigned int neighbour_id;

    // since the direction of the force is important, get the signed distance
    // ... MUST subract FROM the CURRENT particle position 
    if (p.m_id == spring->m_particle2->m_id)
    {
      neighbour_id = spring->m_particle1->m_id;
      distance = spring->m_particle2->m_position - spring->m_particle1->m_position;
    }
    else
    {
      neighbour_id = spring->m_particle2->m_id;
      distance = spring->m_particle1->m_position - spring->m_particle2->m_position;
    }

    float distance_mag = Vector3f::distance(spring->m_particle2->m_position, spring->m_particle1->m_position);

    float r = spring->m_rest_length;
    float k = spring->m_stiffness * 1000;

    spring_force += -1*k * (distance.abs() - r) * (distance/distance.abs());

  }

  return spring_force;// / (p.m_attached_spring_ids.size() * particle_mass);
}
